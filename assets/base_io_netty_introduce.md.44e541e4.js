import{_ as s,o as n,c as a,O as l}from"./chunks/framework.1e38657f.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"base/io/netty/introduce.md","filePath":"base/io/netty/introduce.md","lastUpdated":1708792908000}'),o={name:"base/io/netty/introduce.md"},p=l(`<p>Netty 是一个基于 Java 的开源网络应用框架,提供了高性能、异步、事件驱动的网络编程模型。Netty 官方描述 Netty 是一个异步事件驱动的网络应用程序框架,用于快速开发可维护的高性能协议服务器和客户端。Netty 旨在简化网络应用程序的开发,并提供可靠的、可扩展的网络通信能力。Netty 的主要特点包括:</p><ul><li>异步和事件驱动:Netty 采用基于事件驱动和异步的编程模型,使用事件和回调机制处理网络操作。这种模型能够高效地处理大量并发连接,提供更好的可伸缩性和性能。</li><li>高性能:Netty 的设计和实现注重性能和效率。它通过使用非阻塞 IO 和零拷贝技术等优化手段,提供了卓越的网络性能。</li><li>组件化和可重用性:Netty 的设计采用了组件化的思想,提供了一系列易于扩展和重用的组件,如编解码器、处理器、编解码器链、线程模型等,使开发者能够轻松地构建复杂的网络应用。</li><li>多种协议支持:Netty 支持多种网络协议,包括常见的 TCP、UDP、HTTP、WebSocket 等,提供了相应的编解码器和处理器,使开发者能够方便地开发不同协议的应用程序。</li><li>安全性:Netty 提供了一些安全性相关的组件和功能,如 SSL/TLS 支持、加密和解密等,帮助开发者构建安全的网络应用。</li></ul><p>由于其优秀的性能和功能,Netty 广泛应用于构建高性能、可靠的网络服务器和客户端应用,特别适用于网络通信密集型的应用场景,如游戏服务器、聊天应用、实时通信、大规模分布式系统等。使用 Netty 作为网络通信框架的知名开源项目:</p><ul><li>Apache Kafka:一个分布式流处理平台和消息队列系统,使用 Netty 作为底层的网络传输框架。</li><li>RocketMQ:一个分布式消息中间件,使用 Netty 实现了高性能的消息传输。</li><li>gRPC:一个高性能的开源 RPC(远程过程调用)框架,使用 Netty 作为其底层的网络通信引擎。</li><li>Dubbo:一个分布式服务框架,用于构建高性能和可扩展的分布式应用,提供了服务注册、发现、调用和负载均衡等功能,其底层使用 Netty 作为网络通信框架。</li><li>Spring Framework:一个广泛使用的 Java 应用程序开发框架,Netty 被用于实现 Spring WebFlux 模块的反应式编程。</li></ul><h2 id="_1-netty-hello" tabindex="-1">1.Netty Hello <a class="header-anchor" href="#_1-netty-hello" aria-label="Permalink to &quot;1.Netty Hello&quot;">​</a></h2><h3 id="_1-1-netty-实现简单的消息收发" tabindex="-1">1.1 Netty 实现简单的消息收发 <a class="header-anchor" href="#_1-1-netty-实现简单的消息收发" aria-label="Permalink to &quot;1.1 Netty 实现简单的消息收发&quot;">​</a></h3><p>添加 Netty5 依赖:</p><div class="language-groovy"><button title="Copy Code" class="copy"></button><span class="lang">groovy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">dependencies {</span></span>
<span class="line"><span style="color:#A6ACCD;">    implementation </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">io.netty:netty-all:5.0.0.Alpha2</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">package</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">com</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">fly</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">bootstrap</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ServerBootstrap</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">channel</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ChannelInitializer</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">channel</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ChannelPipeline</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">channel</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">EventLoopGroup</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">channel</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">nio</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">NioEventLoopGroup</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">channel</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">socket</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">SocketChannel</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">channel</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">socket</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">nio</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">NioServerSocketChannel</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">handler</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">codec</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">string</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">StringDecoder</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">handler</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">codec</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">string</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">StringEncoder</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">handler</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">logging</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">LogLevel</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">handler</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">logging</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">LoggingHandler</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 使用Netty实现一个Hello服务,支持服务端与客户端简单的消息收发</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">HelloServer</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 创建两个EventLoopGroup(事件循环组),在Netty中,服务器通常接收两类任务:接收连接和处理连接的IO操作,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 为了高效地处理这些任务,Netty使用不同的线程组来分离接收连接和处理 I/O 操作的任务,以此</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 来提高服务器的并发性能。其中:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * - bossGroup:该线程组负责接受传入的连接。它会监听服务器绑定的端口,并接受客户端的连接请求。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 一旦有新的连接建立,bossGroup 将其注册到 workerGroup 中的线程进行进一步处理。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * - workerGroup:该线程组负责处理已经建立的连接的 I/O 操作。一旦连接被接受并注册到</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * workerGroup 中,workerGroup 将负责处理连接的读取和写入操作。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         */</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">EventLoopGroup</span><span style="color:#A6ACCD;"> bossGroup </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NioEventLoopGroup</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">EventLoopGroup</span><span style="color:#A6ACCD;"> workerGroup </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NioEventLoopGroup</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 创建ServerBootstrap对象,用于配置和启动服务器</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#C792EA;">ServerBootstrap</span><span style="color:#A6ACCD;"> serverBootstrap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ServerBootstrap</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 设置线程模型,Netty内部使用基于事件驱动和多线程的线程模型,称为 Reactor 线程模型</span></span>
<span class="line"><span style="color:#A6ACCD;">            serverBootstrap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">bossGroup</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> workerGroup</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 设置通信通道(Channel),Channel是Netty中提供的一个抽象接口,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 表示一个开放的连接,可以进行数据的读取和写入。Channel提供了</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 多个子接口以适应不同的网络通信需求和协议,常见的子接口如下:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * - SocketChannel:用于 TCP 网络套接字的 Channel 实现。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 它提供了对 TCP 连接的读取和写入操作,以及对连接状态的管理。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * - ServerChannel:用于监听传入连接的 Channel 实现。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 它可以接受传入的连接请求，并创建相应的 SocketChannel 用于处理这些连接。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * - UdtChannel:用于支持 UDT（User Datagram Protocol for Transactions）</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 协议的通信。UDT 是一种可靠的、高性能的数据传输协议,特别适用于对传输延迟</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 和可靠性有严格要求的应用。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * - DatagramChannel:用于 UDP 数据报套接字的 Channel 实现。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 它提供了对 UDP 数据包的读取和写入操作，以及对多播和广播的支持。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 其中SocketChannel接口的具体实现如下:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * - NioServerSocketChannel:基于 Java NIO 的 SocketChannel 实现,适用于 TCP 网络套接字。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * - OioSocketChannel:基于传统的阻塞 I/O 的 SocketChannel 实现,适用于旧版的 I/O 模型。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * - EpollSocketChannel:基于 Linux Epoll 的 SocketChannel 实现，</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 适用于 TCP 网络套接字。它提供了更高的性能和可伸缩性</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">channel</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">NioServerSocketChannel</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">class</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * handler()用于向 ChannelPipeline 末尾添加一个新的 ChannelHandler。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * ChannelHandler 是 Netty 中的处理器，用于实现具体的业务逻辑和数据处理。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 它可以处理不同类型的事件，如连接建立、数据读取、数据写入等，并进行相应的操作和响应。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 通过添加不同的 ChannelHandler，可以实现各种功能，如数据解码、数据编码、</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 业务逻辑处理、错误处理、日志记录等。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * ChannelPipeline 是 Netty 中的一个重要概念，它由一系列的 ChannelHandler</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 组成，用于处理传入和传出的数据、事件和状态变化。在ChannelPipeline中</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * ChannelHandler被组织成一个处理链，用于对Channel的数据流进行处理。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 当一个事件或数据通过ChannelPipeline传递时，会被依次经过各个ChannelHandler进行处理和转换。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">handler</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">LoggingHandler</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">LogLevel</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">INFO</span><span style="color:#89DDFF;">))</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * childHandler() 方法是用于向 ServerChannel 的 ChildChannelPipeline 末尾</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 添加一个新的 ChannelHandler。在 Netty 的服务器端，通常会有一个</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * ServerChannel 负责监听和接受客户端的连接请求。一旦有新的连接建立，</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * ServerChannel 会创建一个对应的子 Channel，即 ChildChannel。ChildChannel</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 用于处理与客户端之间的具体通信，包括数据的读写和事件的处理。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 与 handler() 方法不同，childHandler() 方法是针对每个新连接的子 Channel 进行处理，</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 而不是整个 ChannelPipeline。每个新连接都会有自己独立的 ChildChannelPipeline，</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 并且可以根据需要定制不同的数据处理逻辑。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * ChannelInitializer 是 Netty 中的一个特殊的 ChannelHandler，用于在 Channel 被注册到 EventLoop</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 后,对 Channel 进行初始化和配置。ChannelInitializer支持在Channel 注册后自定义配置 ChannelPipeline,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 添加一系列的 ChannelHandler 来处理传入和传出的数据、事件和状态变化。ChannelInitializer抽象类提供了</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * initChannel()方法用于自定义的 Channel 初始化逻辑,在initChannel方法中可以向 ChannelPipeline</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     * 添加各种 ChannelHandler，并配置它们的顺序和参数。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                     */</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">childHandler</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ChannelInitializer</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">SocketChannel</span><span style="color:#89DDFF;">&gt;()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                        /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                         * initChannel()方法自定义的 Channel 初始化逻辑</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                         * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#A6ACCD;font-style:italic;">ch</span><span style="color:#676E95;font-style:italic;">           已注册的Channel</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                         * </span><span style="color:#F78C6C;font-style:italic;">@throws</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#FFCB6B;font-style:italic;">Exception</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                         */</span></span>
<span class="line"><span style="color:#A6ACCD;">                        </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">                        </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">initChannel</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">SocketChannel</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">ch</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Exception</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">                            </span><span style="color:#676E95;font-style:italic;">// 通过Channel获取Channel管道</span></span>
<span class="line"><span style="color:#A6ACCD;">                            </span><span style="color:#C792EA;">ChannelPipeline</span><span style="color:#A6ACCD;"> pipeline </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ch</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pipeline</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">                            </span><span style="color:#676E95;font-style:italic;">// 在通道管道尾部添加通道处理器(ChannelHandler)</span></span>
<span class="line"><span style="color:#A6ACCD;">                            pipeline</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addLast</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">StringDecoder</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 添加字符串解码器</span></span>
<span class="line"><span style="color:#A6ACCD;">                            pipeline</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addLast</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">StringEncoder</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 添加字符串编码器</span></span>
<span class="line"><span style="color:#A6ACCD;">                            pipeline</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addLast</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">HelloServerHandler</span><span style="color:#89DDFF;">());</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 添加自定义处理器</span></span>
<span class="line"><span style="color:#A6ACCD;">                        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">});</span></span>
<span class="line"><span style="color:#89DDFF;">                    </span><span style="color:#676E95;font-style:italic;">// 绑定端口</span></span>
<span class="line"><span style="color:#A6ACCD;">                    serverBootstrap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">bind</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">8888</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">                            </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                             * sync()用于阻塞等待服务器的启动完成。sync()返回一个ChannelFuture</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                             * ,表示服务器的异步操作结果。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                             */</span></span>
<span class="line"><span style="color:#A6ACCD;">                            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sync</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#89DDFF;">                            </span><span style="color:#676E95;font-style:italic;">// 获取Channel</span></span>
<span class="line"><span style="color:#A6ACCD;">                            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">channel</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#89DDFF;">                            </span><span style="color:#676E95;font-style:italic;">// 用于获取表示Channel关闭的ChannelFuture对象</span></span>
<span class="line"><span style="color:#A6ACCD;">                            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">closeFuture</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">                            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sync</span><span style="color:#89DDFF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">InterruptedException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">RuntimeException</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">e</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">finally</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">             * 释放资源。Netty提供了shutdownGracefully()和shutdownNow()用于关闭EventLoopGroup,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">             * 两者区别如下:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">             * - shutdownGracefully():用于优雅地关闭 Netty 的 EventLoopGroup,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">             * shutdownGracefully()会等待所有正在处理的任务完成后再关闭 EventLoopGroup,而</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">             * - shutdownNow():用于立即关闭 Netty 的 EventLoopGroup,shutdownNow()并不会</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">             * 等待正在处理的任务完成。它会强制停止所有的线程，并丢弃尚未完成的任务。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">             * 除此之外,Netty还提供了isShutdown()、isShuttingDown()判断EventLoopGroup是否被终结。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">             */</span></span>
<span class="line"><span style="color:#A6ACCD;">            bossGroup</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">shutdownGracefully</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">            workerGroup</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">shutdownGracefully</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>HelloServerHandler 用于字符串消息的收发。HelloServerHandler 继承了 SimpleChannelInboundHandler 类并重写了 messageReceived()方法,用于处理接收来自客户端的消息。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">package</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">com</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">fly</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">channel</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ChannelHandlerContext</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">netty</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">channel</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">SimpleChannelInboundHandler</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 自定义ChannelHandler(需要实现ChannelHandler接口),实现消息的收发。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * SimpleChannelInboundHandler是ChannelInboundHandlerAdapter 的一个子类,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 间接性实现了ChannelHandler接口,用于处理特定类型的消息。SimpleChannelInboundHandler</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 允许接收一个泛型,表示处理的消息类型。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">HelloServerHandler</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SimpleChannelInboundHandler</span><span style="color:#89DDFF;">&lt;</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * 用于处理接收到的消息</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#A6ACCD;font-style:italic;">ctx</span><span style="color:#676E95;font-style:italic;">           ChannelHandler上下文</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@param</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#A6ACCD;font-style:italic;">msg</span><span style="color:#676E95;font-style:italic;">           接收的消息</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * </span><span style="color:#F78C6C;font-style:italic;">@throws</span><span style="color:#676E95;font-style:italic;"> </span><span style="color:#FFCB6B;font-style:italic;">Exception</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Override</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">protected</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">messageReceived</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">ChannelHandlerContext</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">ctx</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">msg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Exception</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">receive client message:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> msg</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 将数据写入到与ChannelHandlerContext关联的Channel并刷新数据,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 注意:ChannelHandlerContext的write()只是将消息写入到对应的Channel的缓冲区中,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 并不会将消息发送至客户端,若要发送消息请使用flush()。flush()的作用是将</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 所有待发送的数据从内部缓冲区刷新到底层的Socket缓冲区中,并尽可能快地发送给客户端。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * writeAndFlush()用于向对象Channel写入数据,并将Channel中的数据刷新到底层的</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * Socket缓冲区中发送。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * Socket是计算机网络通信中的一种编程接口(网络通讯中抽象概念,表示一个网络连接的一端),它提供了一种</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 通过网络进行数据传输的机制,用于在不同计算机之间建立网络连接,实现数据的发送和接收。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * Socket编程可以用于各种网络协议,如TCP/IP、UDP、HTTP等。它提供了一种灵活的方式来实现网络应用程序,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 例如客户端-服务器模型、点对点通信等。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         */</span></span>
<span class="line"><span style="color:#A6ACCD;">        ctx</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">writeAndFlush</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">client reply message:I&#39;m fine</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="_1-2-netty-启动步骤分析" tabindex="-1">1.2 Netty 启动步骤分析 <a class="header-anchor" href="#_1-2-netty-启动步骤分析" aria-label="Permalink to &quot;1.2 Netty 启动步骤分析&quot;">​</a></h3><p>Netty 启动步骤可以简单分为创建两个 EventLoopGroup(事件循环组)、创建并配置 ServerBootstrap、绑定端口并阻塞等待服务端启动完成、关闭 EventLoopGroup 组四个步骤:</p><ul><li><p>创建 EventLoopGroup 组:在 Netty 中,服务器通常接收两类任务:接收连接和处理连接的 IO 操作,为了高效地处理这些任务, Netty 内部使用基于事件驱动和多线程的线程模型(称为 Reactor 线程模型),采用不同的线程组来分离接收连接和处理 I/O 操作的任务,以此来提高服务器的并发性能。其中:</p><ul><li>bossGroup:该线程组负责接受传入的连接。它会监听服务器绑定的端口,并接受客户端的连接请求。 一旦有新的连接建立,bossGroup 将将其注册到 workerGroup 中的线程进行进一步处理。</li><li>workerGroup:该线程组负责处理已经建立的连接的 I/O 操作。一旦连接被接受并注册到 workerGroup 中,workerGroup 将负责处理连接的读取和写入操作。</li></ul></li><li><p>创建 ServerBootstrap 对象:ServerBootstrap 用于配置和启动服务器。serverBootstrap 使用 group()方法设置线程模型,使用 channel()方法设置通讯通道,使用 handler 用于向 ChannelPipeline 末尾添加一个新的 ChannelHandler,使用 childHandler() 方法用于向 ServerChannel 的 ChildChannelPipeline 末尾添加一个新的 ChannelHandler。</p><ul><li>group():Netty 在处理事件时,提供了串行和并行两种模式: <ul><li>串行模式:使用一个 EventLoop 来处理所有事件,相当于是一个线程。所有连接共用这个 EventLoop,事件将会串行地在这个线程上处理。</li><li>并行模式:使用 parentGroup 和 childGroup 两个 EventLoop 来处理事件,parentGroup 负责接受传入的连接,childGroup 负责处理已经建立的连接的 I/O 操作,每个 EventLoop 绑定一个线程。连接可以分配到不同的 EventLoop,那么这些连接的事件将会并行地在不同的线程上处理。并行模式可以利用多核 CPU 提高系统整体的吞吐量。</li></ul></li><li>channel():Channel 是 Netty 中提供的一个抽象接口,表示一个开放的连接,可以进行数据的读取和写入。Channel 提供了多个子接口以适应不同的网络通信需求和协议,例如 SocketChannel(用于 TCP 网络套接字的 Channel 实现)、UdtChannel(用于支持 UDT 协议的通信)、DatagramChannel(用于 UDP 数据报套接字的 Channel 实现),其中 SocketChannel 最为常用,SocketChannel 提供了三个子类: <ul><li>NioServerSocketChannel:基于 Java NIO 的 SocketChannel 实现,适用于 TCP 网络套接字。</li><li>OioSocketChannel:基于传统的阻塞 I/O 的 SocketChannel 实现,适用于旧版的 I/O 模型。</li><li>EpollSocketChannel:基于 Linux Epoll 的 SocketChannel 实现,适用于 TCP 网络套接字,提供了更高的性能和可伸缩性。</li></ul></li><li>handler():ChannelHandler 是 Netty 中的处理器,用于实现具体的业务逻辑和数据处理。它可以处理不同类型的事件,如连接建立、数据读取、数据写入等,并进行相应的操作和响应。通过添加不同的 ChannelHandler,可以实现各种功能,如数据解码、数据编码、业务逻辑处理、错误处理、日志记录等。ChannelPipeline 是 Netty 中的一个重要概念,它由一系列的 ChannelHandler 组成,用于处理传入和传出的数据、事件和状态变化。在 ChannelPipeline 中 ChannelHandler 被组织成一个处理链,用于对 Channel 的数据流进行处理。当一个事件或数据通过 ChannelPipeline 传递时,会被依次经过各个 ChannelHandler 进行处理和转换。</li><li>childHandler():在 Netty 的服务器端,通常会有一个 ServerChannel 负责监听和接受客户端的连接请求。一旦有新的连接建立,ServerChannel 会创建一个对应的子 Channel,即 ChildChannel。ChildChannel 用于处理与客户端之间的具体通信,包括数据的读写和事件的处理。与 handler() 方法不同,childHandler() 方法是针对每个新连接的子 Channel 进行处理,而不是整个 ChannelPipeline。每个新连接都会有自己独立的 ChildChannelPipeline,并且可以根据需要定制不同的数据处理逻辑。HelloServer 类使用 childHandler()注册了一个 ChannelInitializer,ChannelInitializer 是 Netty 中的一个特殊的 ChannelHandler,用于在 Channel 被注册到 EventLoop 后,对 Channel 进行初始化和配置。ChannelInitializer 支持在 Channel 注册后自定义配置 ChannelPipeline,添加一系列的 ChannelHandler 来处理传入和传出的数据、事件和状态变化。ChannelInitializer 抽象类提供了 initChannel()方法用于自定义的 Channel 初始化逻辑,在 initChannel 方法中可以向 ChannelPipeline 添加各种 ChannelHandler,并配置它们的顺序和参数。</li></ul></li><li><p>绑定端口并阻塞等待服务端启动完成:ServerBootstrap 通过 bind()绑定端口,使用 sync()用于阻塞等待服务器的启动完成。sync()返回一个 ChannelFuture,表示服务器的异步操作结果。</p></li><li><p>关闭 EventLoopGroup 组:Netty 提供了 shutdownGracefully()和 shutdownNow()用于关闭 EventLoopGroup,两者区别如下:</p><ul><li>shutdownGracefully():用于优雅地关闭 Netty 的 EventLoopGroup,shutdownGracefully()会等待所有正在处理的任务完成后再关闭 EventLoopGroup,而</li><li>shutdownNow():用于立即关闭 Netty 的 EventLoopGroup,shutdownNow()并不会等待正在处理的任务完成。它会强制停止所有的线程,并丢弃尚未完成的任务。</li></ul></li></ul><h2 id="_2-reactor-模型" tabindex="-1">2.Reactor 模型 <a class="header-anchor" href="#_2-reactor-模型" aria-label="Permalink to &quot;2.Reactor 模型&quot;">​</a></h2><p>Reactor 模式是一种事件驱动的异步非阻塞 I/O 模型。它用于处理大量的并发连接,在高并发网络编程中很常用。Reactor 模式主要包含以下组件:</p><ul><li>Reactor(反应器):负责监听事件并分发事件,相当于服务端的主循环。</li><li>Acceptor(处理器):接收客户端连接,并创建处理器。</li><li>Handler(处理器):异步非阻塞地处理连接上的 IO 操作。</li></ul><p>Reactor 模式的工作流程如下:</p><ul><li>Reactor 在一个线程中运行,监听客户端请求事件。</li><li>收到事件后,Reactor 会将该事件分发给对应的 Handler。</li><li>Handler 在独立线程中异步处理该事件,finish 后会通知 Reactor。</li><li>Reactor 接受到通知后向客户端发送响应结果。</li></ul><p>Reactor 模式使得服务端能够异步非阻塞地处理大量客户端连接,充分利用多核 CPU。它是高并发网络编程的基础模型之一。Netty 框架中的 IO 线程模型也是基于 Reactor 模式实现的,这使其可以高效处理海量连接。根据 Reactor 和 Handler 的关系不同,Reactor 模式主要可以分为以下几种类型:</p><ul><li>单 Reactor 单线程模型。</li><li>单 Reactor 多线程模型。</li><li>主从多线程 Reactor 模型。</li><li>多 Reactor 多线程模型。</li></ul><h3 id="_2-1-单-reactor-单线程模型" tabindex="-1">2.1 单 Reactor 单线程模型 <a class="header-anchor" href="#_2-1-单-reactor-单线程模型" aria-label="Permalink to &quot;2.1 单 Reactor 单线程模型&quot;">​</a></h3><p>单 Reactor 单线程模型是 Reactor 模式最基本的模型,有一个 Reactor 和一个线程来处理所有事件。Reactor 负责监听事件,收到事件后在同一个线程 dispatch 给某个 Handler 处理。该模式虽然实现简单,但性能和并发处理能力有限。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">package</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">com</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">fly</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">reactor</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">single</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">java</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">*</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">java</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">net</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">ServerSocket</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">java</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">net</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">Socket</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 单Reactor单线程模型,Reactor和Handler在同一个线程中,Reactor负责监听连接,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 收到连接后在同一个线程处理请求,虽然实现简单但无法实现异步和并发处理。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SingleThreadReactor</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     * ServerSocket用于服务端提供网络服务,它工作在传输层(TCP)并负责建立Socket连接</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">ServerSocket</span><span style="color:#A6ACCD;"> serverSocket</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SingleThreadReactor</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">int</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">port</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">serverSocket </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ServerSocket</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">port</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">serve</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 如果serverSocket连接未关闭,则一直阻塞等待处理请求</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#A6ACCD;">serverSocket</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isClosed</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                 * 阻塞等待会一直等待客户端连接,当接收到客户端连接请求时,会返回一个</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                 * 新的Socket实例,Socket与指定客户端建立了点对点连接,可以用来发送接收数据。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                 * Socket与指定客户端建立了点对点连接,可以用来发送接收数据,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                 * 可以通过设置backlog参数来配置等待连接队列的大小</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">                 */</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#C792EA;">Socket</span><span style="color:#A6ACCD;"> socket </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> serverSocket</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">accept</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#82AAFF;">handleRequest</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">socket</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                e</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">printStackTrace</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">handleRequest</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Socket</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">socket</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 从Socket(套接字)获取输入流</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">InputStream</span><span style="color:#A6ACCD;"> input </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> socket</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getInputStream</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 根据输入流创建一个只读输入流</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">InputStreamReader</span><span style="color:#A6ACCD;"> streamReader </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">InputStreamReader</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">input</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">UTF-8</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">OutputStream</span><span style="color:#A6ACCD;"> output </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> socket</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getOutputStream</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">OutputStreamWriter</span><span style="color:#A6ACCD;"> streamWriter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">OutputStreamWriter</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">output</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">UTF-8</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 根据Reader流创建缓冲区读取字符流,BufferedReader实现了缓冲读取机制,它会一次性读取大块</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 数据到缓冲区,然后应用可以从缓冲区获取数据,实现了读取性能的大幅提升</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         */</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">BufferedReader</span><span style="color:#A6ACCD;"> reader </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BufferedReader</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">streamReader</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * readLine()用于从字符输入流中读取一行内容,如果流中没有数据,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * readLine()会进行阻塞等待</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         */</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> message </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> reader</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readLine</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        System</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">out</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">message:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> message</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * PrintWriter类封装了输出流,提供了格式化打印字符串的高效便捷接口,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 支持所有基本数据类型、String、对象、char[]等多种数据类型输出。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * PrintWriter使用内部缓存区存储数据以减少写操作的次数,以此来提高性能,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         * 并且支持自动刷新数据到Socket,无需手动flush。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">         */</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">PrintWriter</span><span style="color:#A6ACCD;"> writer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">PrintWriter</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">streamWriter</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true);</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 向客户端写入数据</span></span>
<span class="line"><span style="color:#A6ACCD;">        writer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">println</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello Client:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> message</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        reader</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">close</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 关闭套接字</span></span>
<span class="line"><span style="color:#A6ACCD;">        socket</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">close</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">package</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">com</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">fly</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">reactor</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">single</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#F78C6C;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">java</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">io</span><span style="color:#89DDFF;">.</span><span style="color:#C792EA;">IOException</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 单Reactor单线程模型启动类</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SingleThreadReactorBootstrap</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">static</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">main</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">String</span><span style="color:#89DDFF;">[]</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">throws</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">IOException</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">SingleThreadReactor</span><span style="color:#A6ACCD;"> reactor </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SingleThreadReactor</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">8888</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">        reactor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">serve</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>在单 Reactor 单线程模型中,Reactor 和 Handler 在同一个线程中,Reactor 负责监听连接,收到连接后在同一个线程处理请求,虽然实现简单但无法实现异步和并发处理。</p><h3 id="_2-2-单-reactor-多线程模型" tabindex="-1">2.2 单 Reactor 多线程模型 <a class="header-anchor" href="#_2-2-单-reactor-多线程模型" aria-label="Permalink to &quot;2.2 单 Reactor 多线程模型&quot;">​</a></h3><p>Reactor 仍只有一个,但有多个线程来处理事件。Reactor 将请求分发给不同的 Handler,Handler 运行在不同线程上以实现并发处理。线程池可以用来管理 Handler 线程。</p><h3 id="_2-3-主从多线程-reactor-模型" tabindex="-1">2.3 主从多线程 Reactor 模型 <a class="header-anchor" href="#_2-3-主从多线程-reactor-模型" aria-label="Permalink to &quot;2.3 主从多线程 Reactor 模型&quot;">​</a></h3><p>有一个主线程作为主 Reactor,其他线程作为从 Reactor。主 Reactor 负责监听连接事件,从 Reactor 负责 IO 读写。来自同一客户端的所有请求都由同一个从 Reactor 处理。</p><h3 id="_2-4-多-reactor-多线程模型" tabindex="-1">2.4 多 Reactor 多线程模型 <a class="header-anchor" href="#_2-4-多-reactor-多线程模型" aria-label="Permalink to &quot;2.4 多 Reactor 多线程模型&quot;">​</a></h3><p>有多个 Reactor,每个 Reactor 及其线程可以监听不同端口,或者监听同一端口的不同连接。多个 Reactor 实现任务分离,Reactor 线程负责监听,Handler 线程池负责处理 IO。</p><h3 id="_2-5-netty-reactor-模型" tabindex="-1">2.5 Netty Reactor 模型 <a class="header-anchor" href="#_2-5-netty-reactor-模型" aria-label="Permalink to &quot;2.5 Netty Reactor 模型&quot;">​</a></h3><p>Netty 提供单 Reactor 单线程、单 Reactor 多线程、主从 Reactor 多线程等线程模型:</p><ul><li>单 Reactor 单线程:一个 Reactor 线程负责所有的事件处理,相当于一个线程池中只有一个线程,适用于小量简单连接。在 Netty 通过 EventLoopGroup 构造方法传入 1 表示单线程模式,例如:<code>EventLoopGroup group = new NioEventLoopGroup(1);</code>。在单线程模式下 ChannelPipeline(Channel 管道链)使用一个线程处理所有 Handler,会将所有的 Handler 添加到同一个 ChannelPipeline 中,这样所有事件都在一个线程中处理。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 通过EventLoopGroup构造方法传入1表示单线程模式</span></span>
<span class="line"><span style="color:#C792EA;">EventLoopGroup</span><span style="color:#A6ACCD;"> group </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NioEventLoopGroup</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#C792EA;">ServerBootstrap</span><span style="color:#A6ACCD;"> bootstrap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ServerBootstrap</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 配置线程模型</span></span>
<span class="line"><span style="color:#A6ACCD;">bootstrap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">group</span><span style="color:#89DDFF;">);</span></span></code></pre></div><ul><li>单 Reactor 多线程:一个 Reactor 线程监听事件,但根据事件类型派发给不同的 handler 线程池进行处理,提高吞吐量。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * NioEventLoopGroup创建的线程数与以下几个参数相关:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * - ioRatio:IO任务和非IO任务的执行线程数比例,默认8。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * - 初始化线程数:NioEventLoopGroup(int nThreads)支持构造函数</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 指定初始化的线程数,默认是CPU核心数 * 2。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * - 启动时线程数:在Netty服务启动时,会调用NioEventLoopGroup的next()</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 方法获取下一个EventLoop来处理Channel。这个过程中会延迟创建线程,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 线程数取决于处理的Channel数。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * - 最大线程数:通过调用setMaximumPoolSize()可以限制EventLoop的最大线程数。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> *</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * - 线程增长步长:在运行时可以通过步长逐渐增加线程数,防止创建过多空闲线程。</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">EventLoopGroup</span><span style="color:#A6ACCD;"> group </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NioEventLoopGroup</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">ServerBootstrap</span><span style="color:#A6ACCD;"> bootstrap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ServerBootstrap</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 配置线程模型为单Reactor多线程模型</span></span>
<span class="line"><span style="color:#A6ACCD;">bootstrap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">group</span><span style="color:#89DDFF;">);</span></span></code></pre></div><ul><li>主从 Reactor 多线程:一个主 Reactor 线程监听连接事件,接收新连接后分离给从 Reactor 线程处理后续 IO 事件,减少主线程负载。主从 Reactor 多线程模式也是 Netty 最常规写法。</li></ul><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 创建两个EventLoopGroup,主Reactor负责接受传入的连接,用于分配给从Reactor,</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 从Reactor用于IO处理</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">EventLoopGroup</span><span style="color:#A6ACCD;"> bossGroup </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NioEventLoopGroup</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">EventLoopGroup</span><span style="color:#A6ACCD;"> workerGroup </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">NioEventLoopGroup</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#C792EA;">ServerBootstrap</span><span style="color:#A6ACCD;"> bootstrap </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ServerBootstrap</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">bootstrap</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">bossGroup</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> workerGroup</span><span style="color:#89DDFF;">);</span></span></code></pre></div><ul><li>主从 Reactor 多线程池:相比于主从 Reactor,从 Reactor 使用线程池而不是单线程,来处理 IO 事件,更灵活。</li></ul><h2 id="channelhandler" tabindex="-1">ChannelHandler <a class="header-anchor" href="#channelhandler" aria-label="Permalink to &quot;ChannelHandler&quot;">​</a></h2><p>ChannelHandler 是 Netty 提供的一个抽象接口,用于处理 I/O 事件或拦截 I/O 操作,并将其转发到 ChannelPipeline 中的下一个 Handler。ChannelHandler 具有多个子类(例如 ChannelHandlerAdapter、WebSocketFrameDecoder、WebSocketFrameEncoder 等),其中 ChannelHandlerAdapter 类是 ChannelHandler 的适配器类,提供了 ChannelHandler 的骨架实现,用于简化实现 ChannelHandler 接口的过程。在实际开发中通常不会直接实现 ChannelHandler 接口或继承 ChannelHandlerAdapter 类,而是扩展 ChannelHandlerAdapter 的子类,ChannelHandlerAdapter 提供大量子类,常用子类如下:</p><ul><li>SimpleChannelInboundHandler:一个抽象类,允许显式地仅处理特定类型的消息。</li><li>IdleStateHandler:一个用于处理连接空闲状态的处理器。它可以检测连接在一段时间内没有读取或写入数据的情况,并触发 IdleStateEvent 事件。使用 IdleStateHandler 可以实现: <ul><li>心跳检测:通过定期发送心跳消息并检测对方是否响应,来判断连接是否存活。当连接的读取或写入空闲时间超过预设的阈值时,可以触发相应的事件,例如关闭连接或发送心跳消息。</li><li>超时处理:对于长时间没有读取或写入数据的连接,可以设置超时时间,并在超时发生时执行相应的操作,如断开连接或发送超时通知。</li></ul></li><li>ReadTimeoutHandler:用于处理读超时事件,如果在一定时间内没有读取数据,则引发 ReadTimeoutException。</li><li>WriteTimeoutHandler:用于处理写超时事件,如果在一定时间内没有写入数据时,引发 WriteTimeoutException。</li><li>ChannelInitializer:一个特殊的 ChannelHandler,用于在 Channel 注册时初始化 Channel 的 Pipeline。它通常用于配置 Channel 的初始状态,例如添加各种处理器和编解码器。</li><li>CorsHandler:用于处理跨源资源共享 (CORS) 请求,该 Handler 可以使用 CorsConfig 进行配置</li><li>ChunkedWriteHandler:用于将大数据流分块写入到 Channel 中,以避免一次性写入大量数据导致的内存占用问题。ChannelHandler 添加了对异步写入大型数据流的支持,既不会花费大量内存,也不会出现 OutOfMemoryError。 在传输大数据流需要在 ChannelHandler 实现中进行复杂的状态管理,ChunkedWriteHandler 内部提供了复杂的状态管理功能,以便于更简单的发送大数据流。</li><li>LoggingHandler:使用日志框架记录所有事件的 ChannelHandler。 默认情况下,所有事件都在 DEBUG 级别记录。</li><li>SpdySessionHandler:用于管理 SPDY 会话中的流。</li><li>WebSocketServerExtensionHandler:该处理程序协商并初始化 WebSocket 扩展。 它根据客户端所需的顺序协商扩展,确保成功协商的扩展在它们之间是一致的,并使用扩展解码器和编码器初始化通道管道。 在 <code>io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketServerCompressionHandler</code> 中查找压缩扩展的基本实现。</li><li>WebSocketClientExtensionHandler:该处理程序协商并初始化 WebSocket 扩展。 该实现按照定义的顺序与服务器协商扩展,确保成功协商的扩展在它们之间是一致的,并使用扩展解码器和编码器初始化通道管道。 在 <code>io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler</code> 中查找压缩扩展的基本实现。</li></ul>`,44),e=[p];function t(c,r,y,i,C,D){return n(),a("div",null,e)}const E=s(o,[["render",t]]);export{A as __pageData,E as default};
