## 1.Java 中基础类型有哪些?

在 Java 中类型可分为基本类型(也称原始类型)和引用类型:

- 基本类型:int、boolean、byte、char、short、float、long、double。
- 引用类型:包括类、接口、数组等。注意:引用类型的变量存储的是对象的引用,而不是对象本身。

Java 为基本类型提供了对应的包装类型,包装类型属于引用类型,其默认值都为 null。基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成,即基本类型赋值给包装类型称为装箱,包装类型赋值给基本类型称为拆箱。

| 类型    | 占用大小(字节) | 默认值 | 取值范围                                    | 描述                  | 对应的包装类型 |
| ------- | -------------- | ------ | ------------------------------------------- | --------------------- | -------------- |
| boolean | 1              | false  | true 或者 false                             | 用于表示布尔值        | Boolean        |
| byte    | 1              | 0      | -128 到 127                                 | 用于表示字节流数据    | Byte           |
| char    | 2              | 空     | 0 到 65535                                  | 用于表示 Unicode 字符 | Char           |
| short   | 2              | 0      | -32768 到 32767                             | 用于表示较小的整数    | Short          |
| int     | 4              | 0      | -2147483648 到 2147483647                   | 用于表示整数          | Integer        |
| float   | 4              | 0.0    | ±1.4e-45 到 ±3.4e+38                        | 用于表示单精度浮点数  | Float          |
| long    | 8              | 0      | -9223372036854775808 到 9223372036854775807 | 用于表示较大的整数    | Long           |
| double  | 8              | 0.0    | ±4.9e-324 到 ±1.8e+308                      | 用于表示双精度浮点数  | Double         |

## 2.什么是拆箱和装箱?

基本类型都有对应的包装类型,包装类型属于引用类型。**基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成,即基本类型赋值给包装类型称为装箱,包装类型赋值给基本类型称为拆箱**。

```java
// 装箱,
Integer x = 2;
// 拆箱
int y = x;
```

## 3.类型转换?

在 Java 中类型转换分为隐式转换和强制类型转换两种:

- 隐式转换:隐式转换又称自动转换,是指在不需要特别指定的情况下,由编译器自动进行的类型转换。以下情况会发生隐式转换:
  - 将一个小范围的数据类型赋值给一个大范围的数据类型。例如,将一个整数类型的值赋值给长整数类型。
  - 将字面值常量赋值给变量。例如,将整数常量赋值给 byte 或 short 类型的变量。
  - 表达式中的二元运算符操作数类型不匹配时,编译器会自动进行类型提升以进行计算。

```java
int x = 1;
long y = x; // 隐式转换,int转为long
```

- 强制转换:强制转换是指通过强制指定类型,将一个数据类型转换为另一个数据类型。这种转换需要在代码中显式地指定,并且可能导致数据丢失或溢出。强制转换的语法为将目标类型放在圆括号中,紧跟在要转换的表达式或变量之前。

## 4.== 与 equal()的区别?

## 5.int 与 Integer 的区别?

- int 属于基本类型,指向存储的数值,而 Integer 是 int 的包装类,属于引用类型,指向 Integer 实例化后的对象。
- Integer 声明的变量必须实例化后才能使用,int 声明的变量无需实例化也能使用。
- int 的默认值为 0,Integer 的默认值为 null。

```java
// (1).Integer变量实际上是对一个Integer对象的引用,所以两个通过new实例化的Integer永不相等
Integer n1 = new Integer(1);
Integer n2 = new Integer(1);
System.out.println(n1 == n2); // false


// (2).Integer变量与int变量比较时,只要数值相等,则比较结果为true。包装类型与基本类型比较时,Java会自动将包装类型拆箱为基本类型,然后进行比较
Integer n3 = 100;
int n4 = 100;
System.out.println(n3 == n4); // true

// (3).通过new实例化声明的Integer变量与Integer声明的变量比较时,结果为false。通过new实例化声明的Integer变量指向JVM内存区域堆中新创建的对象,
// 而Integer声明的变量指向Integer内部静态常量池中cache数组存储的指向堆的Integer对象,两者引用的内存地址不同
Integer x = 100;
Integer y = new Integer(100);
System.out.println(x == y); // false


// (4).两个Integer声明的变量比较时,如果两个变量的值在-128到127之间,则比较结果为true,超出该区间结果为false。为了提升初始化性能,Integer内部使用静态常量池
// 初始化了-128到127区间的数值,当Integer声明的变量数值相同时,本质上指向的是同一块内存地址

Integer int1 = 100;
Integer int2 = 100;
System.out.println(int1 == int2); // true,由于Integer数值范围处于-128到127之间,因此int1与int2复用静态常量池Integer对象,指向同一块内存地址

Integer int3 = 128;
Integer int4 = 128;
System.out.println(int3 == int4); // false
```

## 6.String 为什么被设计成不可变的?

String.class 使用 final 关键字修饰,final 修饰类时表示该类无法被继承,其主要原因如下:

- **可以缓存 hash 值**。String 在 Java 中经常用作 Map 的 key,如果字符串是可变的,那么它的值被修改后,可能会导致 Map 中出现错误的 Key-Value 对。String 不可变的特性可以使得 hash 值也不可变,因此只需要进行一次计算。
- **String Pool 的需要**。如果一个 String 对象已经被创建过了,那么就会从 String Pool 中取得引用。只有 String 是不可变的,才可能使用 String Pool。不可变字符串可以被缓存,因为它们的值永远不会改变,所以可以在多个地方重复使用,提高性能。
- **提升安全性**。String 的不可变性还可以提高字符串的安全性,例如在网络传输中,不可变的字符串可以防止被篡改。
- **线程安全**。String 不可变性天生具备线程安全,因此可以在多个线程中安全地使用。

## 7.StringBuilder 与 StringBuffer 的区别?

由于 String 对象是不可变对象,因此对字符串进行修改操作时(例如字符串拼接、替换)总是会生成新的 String 对象,所以其性能相对较差。为此,JDK 专门提供了 StringBuffer 和 StringBuilder 分别用于创建和修改字符串。两者区别如下:

- 可变性。从可变性方面来看,String 属于不可变,而 StringBuilder 和 StringBuffer 都属于可变的。
- 线程安全。从线程安全方面来看,由于 String 具有不可变性,因此是线程安全的;StringBuilder 内部没有使用锁机制来保证线程安全,因此是非线程安全的;而 StringBuffer 内部使用 synchronized(同步机制)进行同步访问,因此是线程安全的。在不需要保证线程安全的场景下,推荐使用 StringBuilder,因其内部没有加锁,所以性能相对更好。

| 对比项   | String | StringBuilder | StringBuffer                          |
| -------- | ------ | ------------- | ------------------------------------- |
| 可变性   | 不可变 | 可变          | 可变                                  |
| 线程安全 | 是     | 否            | 是,内部采用 synchronized 保证线程安全 |
| 是否加锁 | 否     | 否            | 是                                    |

## 8.String 拼接字符串的方式有哪些?

在 Java 中大致有六种方式拼接字符串:

- 通过+拼接字符串。
- 通过 String.concat()拼接字符串。
- 使用 StringBuffer 或者 StringBuilder 拼接字符串。
- 使用 String.format()拼接字符串。String.format()是一个用于格式化字符串的方法,String.format()方法以一个格式化字符串作为参数,然后根据格式化字符串中的占位符和参数类型,将传入的参数进行格式化,并返回一个格式化后的字符串。String.format() 方法的格式串中的占位符都以百分号(%)开始,后面紧跟一个转换字符,用于指定参数类型和格式化选项。String.format() 方法的占位符有以下几种:
  - %s 表示字符串类型。
  - %c 表示字符类型。
  - %b 表示布尔类型。
  - %d 表示整数类型(十进制)。
  - %o 表示整数类型(八进制)。
  - %x 表示整数类型(十六进制)。
  - %f 表示浮点数类型。
  - %e 表示科学计数法类型。
  - %t 表示日期时间类型。
  - %% 表示百分号(%)本身。
  - %n 表示换行符。
- 使用 String.join()连接字符串。
- 使用 StringJoiner 连接字符串。StringJoiner 是 Java 8 中的一个新特性,它是一个用于将多个字符串连接起来的工具类。它可以将多个字符串按照指定的分隔符连接起来,同时可以在连接的字符串前后添加指定的前缀和后缀。StringJoiner 类提供了方便的 API 来完成这些任务,使字符串的处理变得更加方便和高效。

## 9.new String("abc")创建了几个对象?

## 10.JDK8 和 JDK9 的 String 有什么区别?

- 内部存储结构不同。在 JDK8 内部使用 char 数组存储数据,但在 JDK9 中内部使用 byte 数组存储数据。使用 char 数组存储数据每个字符占用 2 个字节的存储空间(UTF-16 编码);JDK9 使用 byte 数组存储数据,对于只包含 ASCII 字符的字符串,每个字符只需要一个字节的存储空间,相比于每个字符需要两个字节的存储空间,可以将内存使用减少一半。这种优化在处理大量字符串对象时尤为显著,特别是在应用程序需要存储大量文本数据时,可以降低内存占用并提升整体性能。
- COMPACT_STRINGS:JDK 9 引入了一个名为 COMPACT_STRINGS(压缩字符串)的新特性。它允许 String 类在某些情况下以较低的内存开销存储字符串。具体来说,当字符串仅包含拉丁字母(Latin-1 字符集)时,String 类使用单字节存储每个字符,从而节省了内存。
- 其他改进:JDK 9 还对字符串类进行了其他一些改进,包括更好的 Unicode 支持、更高效的 substring 操作、更好的正则表达式性能等。

## 11.Java 的权限修饰符有哪些?

Java 中的访问权限修饰符用于控制类、接口、成员变量和方法的访问权限。Java 提供了四种访问权限修饰符:

- public(公共的):使用 public 修饰时,表示在任何地方都可以访问,没有访问限制。public 修饰符通常用于修饰公有属性和方法,以供其他类调用。
- default(默认的):当不使用权限修饰符时,表示在同一包内可以访问,其他包中的类无法访问。
- protected(受保护的):使用 protected 修饰时,表示在同一包内和子类中可以访问,其他包中的类无法访问。protected 修饰符通常用于会被子类继承的方法和属性。
- private(私有的):使用 private 修饰时,表示仅在同一类中可以访问,其他类无法访问。private 修饰符通常用于类内部私有方法和属性,以确保外部不可访问。

四种权限修饰符的作用范围如下:
|修饰符|同一个类|同一个包|不同包的子类|不同包的非子类|
|-|-|-|-|-|
|public|√|√|√|√|
|protected|√|√|√||
|default|√|√|||
|private|√||||

## 12.重写和重载的区别?

重写和重载是两种常见的方法设计手段,用于提供代码灵活性和可扩展性。两者区别如下:
重写:方法重写指的是在子类中重新定义(实现)与父类中同名、参数列表相同的方法。子类的重写方法应该确保具有相同的方法签名,即方法名称、参数类型和返回类型都应该相同。在 Java 中需要使用@Override 注解标识被重写的方法,该注解可以帮助编译器检查是否正确重写了父类的方法。重写是实现多态的核心机制,子类重写父类的方法提供具体实现,当调用对象是父类类型但实际引用的是子类对象时,会根据对象的实际类型来调用相应的方法,从而实现面向对象的多态特性。

重载:方法重载指的是在同一个类中,可以定义多个方法,它们具有相同的名称但参数列表不同(方法的参数列表可以包括参数的类型、个数或顺序),允许有不同的返回值。方法重载机制提供了方法的多种使用方式,可以根据不同的参数调用相应的方法。

## 13.final、finalize、finally 的区别?

- final:Java 的关键字之一, 用于声明不可变的变量,也可以用于修饰类、方法或变量。
  - final 修饰实例变量时,该变量必须在创建对象时进行初始化,并且一旦被赋值后就不能再修改;修饰静态变量时,该变量必须在声明时或静态初始化块中进行初始化,并且一旦被赋值后就不能再修改;修饰局部变量时,该变量必须在声明时进行初始化,并且一旦被赋值后就不能再修改。
  - final 修饰方法时,该方法无法被子类重写。
  - final 修饰类时,该类无法被继承。
- finalize():finalize() 是 Object 类中的一个方法,用于在对象被垃圾收集器回收之前执行一些清理操作,该方法在对象被垃圾收集时会被自动调用。由于 finalize()的执行取决垃圾收集器的调度,如果不触发垃圾回收(GC)finalize()将永远都不会执行。因此,不推荐使用 finalize()进行资源释放,更好的做法是使用 try-with-resources 或 finally 块来确保资源的正确释放。
- finally:finally 是 Java 异常处理关键字,用于定义在 try 块或 try-catch 块执行之后总是执行的代码块,通常用于资源释放,例如关闭数据库连接、关闭 IO 流等操作。

## 14.为什么重写 equals()必须重写 hashCode()?

如果重写 equals()方法必须重写 hashCode(),在 Object 类中,hashCode() 的默认实现是基于对象的内存地址生成的,如果不重写 hashCode()方法,会导致两个相等的对象会产生不一致的哈希码,无法正确在哈希集合(HashMap 或 HashSet)中查找对象。当对象被添加到哈希集合中时,两个相等的对象因为 hashCode 不同,会被分配到不同的哈希桶,可能会导致不必要的哈希冲突,造成性能下降。

## 15.什么是反射机制?

Java 反射机制是指在 Java 应用运行中,对于任意一个类,都可以获取该类的所有属性和方法; 对于任意一个对象,都可以调用它的任意一个方法和属性。这种在运行时动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。虽然反射机制具有较强的灵活性、无侵入性、支持动态代理(允许在运行时动态地生成代理类和对象,实现 AOP)
等优点,使用反射时涉及动态类型检查、方法查找和动态调用等操作,因此使用反射存在性能开销较大、类型安全性较差等问题。反射常用优化策略如下:

- 缓存反射对象:通过缓存反射对象(Class、Method、Field 等)来避免重复的反射操作,提高性能。这样可以在第一次反射获取对象后,将其缓存起来供后续使用。
- 接口优先于反射:对于某些场景下,可以基于接口优先反射策略,使用接口避免反射操作。接口允许在运行期间方法直接调用,调用过程没有反射开销,而且支持编译期检查。
- 使用字节码技术:字节码技术是指通过操作程序的字节码（bytecode）来实现对程序行为的控制和修改。字节码是一种介于源代码和机器代码之间的中间代码,通常是一种由虚拟机执行的二进制指令集。在 Java 和其他一些编程语言中,源代码经过编译器生成字节码,然后由虚拟机执行。在 Java 中可以借助如 ASM、CGLIB、Byte Buddy 字节码库在运行时创建新的类、修改类的结构、动态生成方法,中间过程无反射开销。字节码库的工作原理如下:使用字节码库动态生成一个类时,首先通过 ClassLoader 机制将该类动态加载至 JVM 中,然后利用 Java 的多态机制,利用接口或抽象类的方式去调用这个被 JVM 载入内存中类,中间过程无反射开销,因此性能非常好。
- 使用 Unsafe 优化反射:Unsafe 类是 Java 中的一个特殊类,位于 `sun.misc` 包中,提供了直接访问底层内存的方法。虽然它不是官方公开的 API,但在一些特殊场景下，它被用来进行一些高性能的操作,包括优化反射。Unsafe 支持直接获取字段的内存偏移、直接操作对象的内存、直接分配内存、直接复制内存、绕过构造函数创建对象等操作,由于 Unsafe 操作涉及到直接内存管理,可能引入一些潜在的安全问题,如内存泄漏、越界访问等。

## 16.什么是类型擦除?

**Java 泛型通过类型擦除(Type Erasure)来实现的,这意味着在编译时,泛型的类型信息会被擦除,而在运行时,Java 虚拟机操作的是擦除后的原始类型。Java 的类型擦除是指在编译时所有泛型类型参数都会被擦除,泛型的类型参数会被替换为它们的上界(对于没有指定上界的类型参数,默认是 Object)。类型擦除降低了在运行时保留泛型类型信息的开销,有助于减少程序在内存使用和性能方面的负担,而且类型擦除还支持向后兼容,可以提高代码的灵活性**。虽然类型擦除具有诸多优点,但存在着如下问题:

- **可能会出现运行时异常**。由于类型擦除会在编译时将泛型参数替换为 Object,因此,Java 泛型无法在运行时获取具体的泛型类型,在类型转换下可能会出现 ClassCastException(类转换)异常。
- **泛型类型参数不能是基本类型**。由于 Java 泛型是通过类型擦除实现的,而基本类型在 Java 中属于非引用类型,因此,基本类型无法作为泛型类型的参数。在使用泛型时必须使用对应的包装类(Wrapper Classes)作为泛型类型参数。
- **无法创建泛型类型的实例**。由于类型擦除的存在,Java 泛型无法在运行时创建泛型类型的实例。例如,无法使用 new T()创建一个泛型类型 T 的实例,经过类型擦除后,T 被转为 Object 类型,因此也无法创建泛型数组。
- **泛型类型参数不能使用 instantof**。泛型参数类型经过类型擦除后,无法在运行时无法直接获取泛型类型参数的具体类型信息。因此,无法在运行时使用 instanceof 操作符来检查一个对象是否是某个泛型类型的实例。
- **无法重载泛型方法**。在类型擦除的过程中,方法的参数和返回类型的泛型信息被擦除,编译器无法在运行时识别它们的具体类型。这种擦除可能导致编译器无法区分两个在类型参数上有不同约束的泛型方法,从而无法重载泛型方法。

## 17.Java BIO、NIO、AIO 是什么?

## 18.什么是 SPI 机制?
