### 1.TCP 粘包和拆包问题

TCP 粘包和拆包问题是在 TCP 协议下进行数据传输时可能遇到的两种常见问题:

- TCP 粘包（TCP Packet Sticking）:由于 TCP 是一种面向流的协议,它以字节流的形式传输数据。当发送方连续发送多个小数据包时,TCP 协议会将这些数据包组合成更大的数据块进行传输,以提高传输效率。但在接收方,由于 TCP 的接收缓冲区是以字节流方式接收数据,因此接收方无法知道每个数据包的边界。这导致接收方可能会一次性读取到多个数据包,即发生 TCP 粘包现象。

- TCP 拆包（TCP Packet Splitting）:与 TCP 粘包相反，TCP 拆包问题是指当发送方发送的数据包比接收方的接收缓冲区小或者发送方发送的数据包被分割成多个数据包发送时，接收方可能无法正确拆分这些数据包，导致接收方接收到不完整的数据包或者多个不完整的数据包。

由于 TCP 协议是一种面向流的协议，它不保留原始数据包的边界信息,数据传输过程了可能会出现 TCP 粘包/拆包问题,导致传输数据的不正确和不完整。解决 TCP 粘包和拆包问题的方案如下:

- 消息定长:通过固定长度的消息进行通信,无论消息实际长度如何,都按照固定长度进行拆包和粘包处理。这种方式要求发送和接收双方都遵循相同的消息长度规定。
- 消息分隔符:通过在消息中使用特定的分隔符来标识消息的边界。发送方在消息末尾添加分隔符,接收方通过分隔符将接收到的数据进行拆分。Netty 提供了 DelimiterBasedFrameDecoder 和 StringDecoder 等解码器来支持这种方式。
- 消息长度字段:在消息中添加一个字段来表示消息的长度。接收方首先读取消息长度字段,然后根据长度字段的值读取相应长度的数据。Netty 提供了 LengthFieldBasedFrameDecoder 解码器来支持这种方式。
- 自定义协议:设计自定义的协议,在消息中添加一些特定的标识符或长度字段来标识消息的边界和长度。通过解析协议,可以正确处理粘包和拆包问题。
